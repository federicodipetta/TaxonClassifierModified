def generate_trees(nodes):
    n = len(nodes)
    results = []
    current_tree = [None] * n
    current_tree[0] = nodes[0]  # Root is always present

    def backtrack(index):
        if index >= n:
            results.append(current_tree.copy())
            return

        parent_index = (index - 1) // 2
        # If parent is not present, this node cannot be present
        if current_tree[parent_index] is None:
            current_tree[index] = None
            backtrack(index + 1)
        else:
            # Option 1: Node is not present
            current_tree[index] = None
            backtrack(index + 1)
            # Option 2: Node is present
            current_tree[index] = nodes[index]
            backtrack(index + 1)

    backtrack(1)  # Start from index 1 since root is already set
    return results

# Helper to print each tree
def print_tree(tree_list):
    return tree_list

def valid_tree(tree):
    n = len(tree)
    for i in range(1, n):
        if tree[i] is not None:
            parent_index = (i - 1) // 2
            if tree[parent_index] is None:
                return False
    return True

# Example usage4
for h in range(2, 6):
    nodes = [i for i in range(1, 2**h)]
    trees = generate_trees(nodes)
    trees = set(map(tuple, trees))  # Convert to set to remove duplicates
    count = 0
    print(f"Height: {h}")
    print(f"number of trees: {len(trees)}")

print(f"Number of invalid trees: {count}")
print(f"The trees generated by the nodes {nodes} are {len(trees)}")